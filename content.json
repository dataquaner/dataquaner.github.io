{"meta":{"title":"DataQuaner","subtitle":"","description":"Data & Algorithm & Business & Value","author":"Leon","url":"https://dataquaner.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-11-14T14:27:21.000Z","updated":"2019-11-14T14:28:04.822Z","comments":true,"path":"about/index.html","permalink":"https://dataquaner.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-10T09:22:35.000Z","updated":"2019-11-10T09:23:03.650Z","comments":true,"path":"categories/index.html","permalink":"https://dataquaner.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-11-10T09:17:30.000Z","updated":"2019-11-10T09:20:41.842Z","comments":true,"path":"link/index.html","permalink":"https://dataquaner.github.io/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-10T09:21:38.000Z","updated":"2019-11-10T09:22:17.868Z","comments":true,"path":"tags/index.html","permalink":"https://dataquaner.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"xgboost算法模型输出的解释","slug":"xgboost算模型输出的解释","date":"2019-12-16T06:46:13.604Z","updated":"2019-12-16T06:46:13.604Z","comments":true,"path":"2019/12/16/xgboost算模型输出的解释/","link":"","permalink":"https://dataquaner.github.io/2019/12/16/xgboost%E7%AE%97%E6%A8%A1%E5%9E%8B%E8%BE%93%E5%87%BA%E7%9A%84%E8%A7%A3%E9%87%8A/","excerpt":"","text":"1. 问题描述 近来, 在python环境下使用xgboost算法作若干的机器学习任务, 在这个过程中也使用了其内置的函数来可视化树的结果, 但对leaf value的值一知半解; 同时, 也遇到过使用xgboost 内置的predict 对测试集进行打分预测, 发现若干样本集的输出分值是一样的. 这个问题该怎么解释呢? 通过翻阅Stack Overflow 上的相关问题, 以及搜索到的github上的issue回答, 应该算初步对这个问题有了一定的理解。 2. 数据集 在这里, 使用经典的鸢尾花的数据来说明. 使用二分类的问题来说明, 故在这里只取前100行的数据. 1234567891011121314from sklearn import datasets iris = datasets.load_iris()data = iris.data[:100]print data.shape#(100L, 4L)#一共有100个样本数据, 维度为4维 label = iris.target[:100]print label#正好选取label为0和1的数据[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] 3. 训练集与测试集123from sklearn.cross_validation import train_test_split train_x, test_x, train_y, test_y = train_test_split(data, label, random_state=0) 4. Xgboost建模4.1 模型初始化设置123456789101112131415161718import xgboost as xgbdtrain=xgb.DMatrix(train_x,label=train_y)dtest=xgb.DMatrix(test_x) params=&#123;'booster':'gbtree', 'objective': 'binary:logistic', 'eval_metric': 'auc', 'max_depth':4, 'lambda':10, 'subsample':0.75, 'colsample_bytree':0.75, 'min_child_weight':2, 'eta': 0.025, 'seed':0, 'nthread':8, 'silent':1&#125; watchlist = [(dtrain,'train')] 4.2 建模与预测1234567891011121314bst=xgb.train(params,dtrain,num_boost_round=100,evals=watchlist) ypred=bst.predict(dtest) # 设置阈值, 输出一些评价指标y_pred = (ypred &gt;= 0.5)*1 from sklearn import metricsprint 'AUC: %.4f' % metrics.roc_auc_score(test_y,ypred)print 'ACC: %.4f' % metrics.accuracy_score(test_y,y_pred)print 'Recall: %.4f' % metrics.recall_score(test_y,y_pred)print 'F1-score: %.4f' %metrics.f1_score(test_y,y_pred)print 'Precesion: %.4f' %metrics.precision_score(test_y,y_pred)metrics.confusion_matrix(test_y,y_pred) Out[23]: 1234567AUC: 1.0000ACC: 1.0000Recall: 1.0000F1-score: 1.0000Precesion: 1.0000array([[13, 0], [ 0, 12]], dtype=int64) Yeah, 完美的模型, 完美的预测! 4.3 可视化输出123456789101112131415#对于预测的输出有三种方式?bst.predictSignature: bst.predict(data, output_margin=False, ntree_limit=0, pred_leaf=False, pred_contribs=False, approx_contribs=False) pred_leaf : bool When this option is on, the output will be a matrix of (nsample, ntrees) with each record indicating the predicted leaf index of each sample in each tree. Note that the leaf index of a tree is unique per tree, so you may find leaf 1 in both tree 1 and tree 0. pred_contribs : bool When this option is on, the output will be a matrix of (nsample, nfeats+1) with each record indicating the feature contributions (SHAP values) for that prediction. The sum of all feature contributions is equal to the prediction. Note that the bias is added as the final column, on top of the regular features. 4.3.1 得分默认的输出就是得分, 这没什么好说的, 直接上code. 12ypred = bst.predict(dtest)ypred Out[32]: 12345array([ 0.20081411, 0.80391562, 0.20081411, 0.80391562, 0.80391562, 0.80391562, 0.20081411, 0.80391562, 0.80391562, 0.80391562, 0.80391562, 0.80391562, 0.80391562, 0.20081411, 0.20081411, 0.20081411, 0.20081411, 0.20081411, 0.20081411, 0.20081411, 0.20081411, 0.80391562, 0.20081411, 0.80391562, 0.20081411], dtype=float32) 在这里, 就可以观察到文章最开始遇到的问题: 为什么得分几乎都是一样的值? 先不急, 看看另外两种输出. 4.3.2 所属的叶子节点当设置pred_leaf=True的时候, 这时就会输出每个样本在所有树中的叶子节点 12ypred_leaf = bst.predict(dtest, pred_leaf=True)ypred_leaf Out[33]: 1234567array([[1, 1, 1, ..., 1, 1, 1], [2, 2, 2, ..., 2, 2, 2], [1, 1, 1, ..., 1, 1, 1], ..., [1, 1, 1, ..., 1, 1, 1], [2, 2, 2, ..., 2, 2, 2], [1, 1, 1, ..., 1, 1, 1]]) 输出的维度为[样本数, 树的数量], 树的数量默认是100, 所以ypred_leaf的维度为[100*100]. 对于第一行数据的解释就是, 在xgboost所有的100棵树里, 预测的叶子节点都是1(相对于每颗树). 那怎么看每颗树以及相应的叶子节点的分值呢?这里有两种方法, 可视化树或者直接输出模型. 12xgb.to_graphviz(bst, num_trees=0)#可视化第一棵树的生成情况 12#直接输出模型的迭代工程bst.dump_model(\"model.txt\") 12345678910111213booster[0]:0:[f3&lt;0.75] yes=1,no=2,missing=1 1:leaf=-0.019697 2:leaf=0.0214286booster[1]:0:[f2&lt;2.35] yes=1,no=2,missing=1 1:leaf=-0.0212184 2:leaf=0.0212booster[2]:0:[f2&lt;2.35] yes=1,no=2,missing=1 1:leaf=-0.0197404 2:leaf=0.0197235booster[3]: …… 通过上述命令就可以输出模型的迭代过程, 可以看到每颗树都有两个叶子节点(树比较简单). 然后我们对每颗树中的叶子节点1的value进行累加求和, 同时进行相应的函数转换, 就是第一个样本的预测值. 在这里, 以第一个样本为例, 可以看到, 该样本在所有树中都属于第一个叶子, 所以累加值, 得到以下值. 同样, 以第二个样本为例, 可以看到, 该样本在所有树中都属于第二个叶子, 所以累加值, 得到以下值. 12leaf1 -1.381214leaf2 1.410950 在使用xgboost模型最开始, 模型初始化的时候, 我们就设置了&#39;objective&#39;: &#39;binary:logistic&#39;, 因此使用函数将累加的值转换为实际的打分: f(x)=1/(1+exp(−x)) 12341/float(1+np.exp(1.38121416))Out[24]: 0.200814071121865031/float(1+np.exp(-1.410950))Out[25]: 0.8039157403338895 这就与ypred = bst.predict(dtest) 的分值相对应上了. 4.3.2 特征重要性接着, 我们看另一种输出方式, 输出的是特征相对于得分的重要性. 12ypred_contribs = bst.predict(dtest, pred_contribs=True)ypred_contribs Out[37]: 12345678910111213141516171819202122232425array([[ 0. , 0. , -1.01448286, -0.41277751, 0.04604663], [ 0. , 0. , 0.96967536, 0.39522746, 0.04604663], [ 0. , 0. , -1.01448286, -0.41277751, 0.04604663], [ 0. , 0. , 0.96967536, 0.39522746, 0.04604663], [ 0. , 0. , 0.96967536, 0.39522746, 0.04604663], [ 0. , 0. , 0.96967536, 0.39522746, 0.04604663], [ 0. , 0. , -1.01448286, -0.41277751, 0.04604663], [ 0. , 0. , 0.96967536, 0.39522746, 0.04604663], [ 0. , 0. , 0.96967536, 0.39522746, 0.04604663], [ 0. , 0. , 0.96967536, 0.39522746, 0.04604663], [ 0. , 0. , 0.96967536, 0.39522746, 0.04604663], [ 0. , 0. , 0.96967536, 0.39522746, 0.04604663], [ 0. , 0. , 0.96967536, 0.39522746, 0.04604663], [ 0. , 0. , -1.01448286, -0.41277751, 0.04604663], [ 0. , 0. , -1.01448286, -0.41277751, 0.04604663], [ 0. , 0. , -1.01448286, -0.41277751, 0.04604663], [ 0. , 0. , -1.01448286, -0.41277751, 0.04604663], [ 0. , 0. , -1.01448286, -0.41277751, 0.04604663], [ 0. , 0. , -1.01448286, -0.41277751, 0.04604663], [ 0. , 0. , -1.01448286, -0.41277751, 0.04604663], [ 0. , 0. , -1.01448286, -0.41277751, 0.04604663], [ 0. , 0. , 0.96967536, 0.39522746, 0.04604663], [ 0. , 0. , -1.01448286, -0.41277751, 0.04604663], [ 0. , 0. , 0.96967536, 0.39522746, 0.04604663], [ 0. , 0. , -1.01448286, -0.41277751, 0.04604663]], dtype=float32) 输出的ypred_contribs的维度为[100,5], 通过阅读前面的文档注释就可以知道, 最后一列是bias, 前面的四列分别是每个特征对最后打分的影响因子, 可以看出, 前面两个特征是不起作用的. 通过这个输出, 怎么和最后的打分进行关联呢? 原理也是一样的, 还是以前两列为例. 123456score_a = sum(ypred_contribs[0])print score_a# -1.38121373579score_b = sum(ypred_contribs[1])print score_b# 1.41094945744 相同的分值, 相同的处理情况. 到此, 这期关于在python上关于xgboost算法的简单实现, 以及在实现的过程中: 得分的输出、样本对应到树的节点、每个样本中单独特征对得分的影响, 以及上述三者之间的联系, 均已介绍完毕。","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://dataquaner.github.io/categories/MachineLearning/"}],"tags":[{"name":"xgboost","slug":"xgboost","permalink":"https://dataquaner.github.io/tags/xgboost/"}]},{"title":"数据存储之MySQL系列（01）：MySQL体系结构","slug":"数据存储之MySQL系列（01）：MySQL体系结构","date":"2019-12-04T13:26:03.118Z","updated":"2019-12-04T13:26:03.118Z","comments":true,"path":"2019/12/04/数据存储之MySQL系列（01）：MySQL体系结构/","link":"","permalink":"https://dataquaner.github.io/2019/12/04/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B9%8BMySQL%E7%B3%BB%E5%88%97%EF%BC%8801%EF%BC%89%EF%BC%9AMySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"","categories":[{"name":"数据存储","slug":"数据存储","permalink":"https://dataquaner.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"name":"MySQL","slug":"数据存储/MySQL","permalink":"https://dataquaner.github.io/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/MySQL/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://dataquaner.github.io/tags/mysql/"},{"name":"体系结构","slug":"体系结构","permalink":"https://dataquaner.github.io/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}]},{"title":"LightGBM算法基础系列之基础理论篇（1）","slug":"LightGBM算法基础系列之基础理论篇（1）","date":"2019-11-14T14:21:29.609Z","updated":"2019-11-14T14:21:29.609Z","comments":true,"path":"2019/11/14/LightGBM算法基础系列之基础理论篇（1）/","link":"","permalink":"https://dataquaner.github.io/2019/11/14/LightGBM%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%881%EF%BC%89/","excerpt":"","text":"这是lightgbm算法基础系列的第一篇，讲述lightgbm基础理论。","categories":[{"name":"MachineLearning","slug":"MachineLearning","permalink":"https://dataquaner.github.io/categories/MachineLearning/"},{"name":"LightGBM","slug":"MachineLearning/LightGBM","permalink":"https://dataquaner.github.io/categories/MachineLearning/LightGBM/"}],"tags":[{"name":"LightGBM","slug":"LightGBM","permalink":"https://dataquaner.github.io/tags/LightGBM/"}]}]}